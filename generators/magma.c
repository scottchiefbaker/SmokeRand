/**
 * @file magma.c
 * @brief CSPRNG based on "Magma" from GOST R 34.12-2015 (version for AVX2)
 * @details "Magma" from GOST R 34.12-2015 is a 64-bit block cipher developed
 * in USSR. It is a Feistel cipher that uses 8 4x4 S-boxes.
 *
 * This MAGMA implementation is the cross-platform one. However, it has very
 * low performance around 25 cpb (10-20 times slower than ChaCha12) and uses
 * around 2KiB of RAM for unrolled permutation tables.
 *
 * References:
 *
 * 1. RFC8891. GOST R 34.12-2015: Block Cipher "Magma"
 *    https://datatracker.ietf.org/doc/html/rfc8891
 * 2. Ludmila Babenko, Evgeniya Ishchukova, and Ekaterina Maro. 2012. Research
 *    about strength of GOST 28147-89 encryption algorithm. In Proceedings of
 *    the Fifth International Conference on Security of Information and
 *    Networks (SIN '12). Association for Computing Machinery, New York, NY,
 *    USA, 138-142. https://doi.org/10.1145/2388576.2388595
 * 3. GOST R 34.12-2015 (in Russian)
 *    https://tc26.ru/standard/gost/GOST_R_3412-2015.pdf
 *
 * @copyright (c) 2025 Alexey L. Voskov, Lomonosov Moscow State University.
 * alvoskov@gmail.com
 *
 * This software is licensed under the MIT license.
 */

#include "smokerand/cinterface.h"

PRNG_CMODULE_PROLOG


typedef struct {
    uint32_t k[8];
} MagmaKey256;

typedef struct {
    uint32_t sbox8[4][256];
    MagmaKey256 key;
    uint64_t ctr;
} MagmaState;

static const unsigned char sbox4[8][16] = {
    {12, 4, 6, 2, 10, 5, 11, 9, 14, 8, 13, 7, 0, 3, 15, 1}, // 0
    {6, 8, 2, 3, 9, 10, 5, 12, 1, 14, 4, 7, 1, 13, 0, 15},
    {11, 3, 5, 8, 2, 15, 10, 13, 14, 1, 7, 4, 12, 9, 6, 0},
    {12, 8, 2, 1, 13, 4, 15, 6, 7, 0, 10, 5, 3, 14, 9, 11},
    {7, 15, 5, 10, 8, 1, 6, 13, 0, 9, 3, 14, 11, 4, 2, 12},
    {5, 13, 15, 6, 9, 2, 12, 10, 11, 7, 8, 1, 4, 3, 14, 0},
    {8, 14, 2, 5, 6, 9, 1, 12, 15, 4, 11, 0, 13, 10, 3, 7},
    {1, 7, 14, 13, 0, 5, 8, 3, 4, 15, 10, 6, 9, 12, 11, 2} // 7
};

void MagmaState_init(MagmaState *obj, const uint32_t *key)
{
    for (int i = 0; i < 4; i++) {
        for (int j1 = 0; j1 < 16; j1++) {
            for (int j2 = 0; j2 < 16; j2++) {
                int index = (j1 << 4) | j2;
                uint32_t s = (sbox4[2*i + 1][j1] << 4) | sbox4[2*i][j2];
                s <<= (8 * i);
                s = (s << 11) | (s >> 21);
                obj->sbox8[i][index] = s;
            }
        }
    }
    for (int i = 0; i < 8; i++) {
        obj->key.k[i] = key[i];
    }
    obj->ctr = 0;
}

static inline uint32_t gfunc(const MagmaState *obj, uint32_t k, uint32_t x)
{
    uint32_t y;
    x += k;
    y  = obj->sbox8[0][x & 0xFF]; //x >>= 8;
    y |= obj->sbox8[1][(x >> 8) & 0xFF]; //x >>= 8;
    y |= obj->sbox8[2][(x >> 16) & 0xFF]; //x >>= 8;
    y |= obj->sbox8[3][(x >> 24)];
    return y;
}

#define MAGMA_ROUND(ind) { t = a1 ^ gfunc(obj, a0, obj->key.k[ind]); a1 = a0; a0 = t; }

EXPORT uint64_t MagmaState_encrypt(const MagmaState *obj, uint64_t a)
{
    uint32_t a1 = a >> 32, a0 = (uint32_t) a;
    uint32_t t;
    for (int i = 0; i < 3; i++) {
        MAGMA_ROUND(0);  MAGMA_ROUND(1);  MAGMA_ROUND(2);  MAGMA_ROUND(3);
        MAGMA_ROUND(4);  MAGMA_ROUND(5);  MAGMA_ROUND(6);  MAGMA_ROUND(7);
    }
    MAGMA_ROUND(7);  MAGMA_ROUND(6);  MAGMA_ROUND(5);  MAGMA_ROUND(4);
    MAGMA_ROUND(3);  MAGMA_ROUND(2);  MAGMA_ROUND(1);  MAGMA_ROUND(0);
    return ( (uint64_t) a0 << 32) | a1;
}

static inline uint64_t get_bits_raw(void *state)
{
    MagmaState *obj = state;
    return MagmaState_encrypt(obj, obj->ctr++);
}

static void *create(const CallerAPI *intf)
{
    MagmaState *obj = intf->malloc(sizeof(MagmaState));
    uint32_t key[8];
    for (int i = 0; i < 4; i++) {
        uint64_t seed = intf->get_seed64();
        key[2*i] = seed >> 32;
        key[2*i + 1] = (uint32_t) seed;
    }
    MagmaState_init(obj, key);
    return (void *) obj;
}


static int run_self_test(const CallerAPI *intf)
{
    // key is taken from the original GOST.
    static const uint32_t key[] = {
        0xffeeddcc, 0xbbaa9988, 0x77665544, 0x33221100,
        0xf0f1f2f3, 0xf4f5f6f7, 0xf8f9fafb, 0xfcfdfeff
    };
    // Only the first ctr-u_ref pair is obtained from the original GOST.
    // Other pairs were generated by means of this (non-vectorized) MAGMA
    // implementation.
    static const uint64_t ctr_in[8] = {
        0xfedcba9876543210, 0x243F69A25B093B12, 0x24C5B22658595D69, 0x0000000000000000,
        0x0123456789ABCDEF, 0xB7E151628AED2A6B, 0xDEADBEEFDEADBEEF, 0xFFFFFFFFFFFFFFFF
    };
    static const uint64_t u_ref[8] = {
        0x4ee901e5c2d8ca3d, 0x55DAEE31ED87E6F7, 0xB644E51E09B20B3E, 0x1BB3E0C407A59322,
        0xA6CB0CB94195EA34, 0x13F900FFCBEEB4FE, 0x9E57E39D28EAC91A, 0x503C956F1519A1A3
    };
    MagmaState *obj = intf->malloc(sizeof(MagmaState));
    MagmaState_init(obj, key);
    int is_ok = 1;
    for (int i = 0; i < 8; i++) {
        obj->ctr = ctr_in[i];
        uint64_t u = get_bits_raw(obj);
        intf->printf("Out = 0x%llX; ref = 0x%llX\n", u, u_ref[i]);
        if (u != u_ref[i]) is_ok = 0;
    }
    intf->free(obj);
    return is_ok;
};

MAKE_UINT64_PRNG("MAGMA-AVX-GOSTR34.12-2015", run_self_test)
