#!/bin/lua
--
-- Creates build.ninja file for SmokeRand.
-- GCC, MinGW, ZIG CC (Clang) and MSVC compilers are supported. This script
-- can be used as a minimialistic replacement of CMake, especially for MSVC.
--
-- Known issues:
--
-- 1. Not all generators can be compiled for the 'gcc32' and 'mingw-hx' 32-bit
--    platform due to 128-bit arithmetics etc. Generators with AVX/AVX2
--    instructions are also excluded from the build for 32-bit platforms.
-- 2. MSVC headers dependency tracing may depend on the system locale because
--    ninja analyses stdout output of the MSVC compiler. Some issues with
--    encodings for non-latin based languages are possible. And this script
--    supports only English version of MSVC.
--

---------------------------------------------
----- Processing command line arguments -----
---------------------------------------------

local platform = ''
if #arg < 1 then
    print(
    [[Usage:
lua cfg_ninja.lua plaform
platform --- generic, gcc, mingw, gcc32, mingw-hx, msvc, zigcc
    generic     gcc-like compiler, no threads and x86 extensions.
    gcc, mingw  gcc compiler (POSIX threads).
    gcc32       gcc compiler, compilation of 32-bit binaries.
    mingw-hx    32-bit binaries friendly to HX DOS extender.
    zigcc       clang from Zig distribution (WinAPI threads).
]])
    return 0
else
    platform = arg[1]
end

-------------------------
----- List of files -----
-------------------------
cfg = require('cfg_data')
local lib_name = "$libdir/libsmokerand_core.a"
local batlib_name = "$libdir/libsmokerand_bat.a"
local lib_sources = cfg.get_lib_sources()
local bat_sources = cfg.get_bat_sources()
local gen_sources_raw = cfg.get_gen_sources()

-- Filter out the floating point based generator: in MSVC
-- it requires a runtime library.
local gen_sources = {}
if platform == 'msvc' then
    for i=1,#gen_sources_raw do
        local gen = gen_sources_raw[i]
        if gen ~= "lfib_ranmar" then
            table.insert(gen_sources, gen)
        end
    end
else
    gen_sources = gen_sources_raw
end


--------------------------------
----- Cross-platform rules -----
--------------------------------

local exe_ext, so_ext = '', '.so'
local stub, stub_crossplatform = '', [[
# NOTE: THIS FILE IS AUTOGENERATED BY cfg_ninja.lua!
# DON'T EDIT IT MANUALLY!
ninja_required_version = 1.3
appsrcdir = apps
srcdir = src
objdir = obj
bindir = bin
libdir = lib
includedir = include/smokerand
gen_bindir = $bindir/generators
gen_srcdir = generators
]]


-----------------------------------
----- Platform-specific rules -----
-----------------------------------

local exe_ext = ''
if os.getenv("OS") == "Windows_NT" then
    exe_ext, so_ext = '.exe', '.dll'
end

-- Rules for gcc/mingw, clang (zig cc)
local gcc_rules = [[
rule cc
    command = $cc -MMD -MT $out -MF $out.d $cflags -c -Iinclude $in -o $out
    description = CC $out
    depfile = $out.d
    deps = gcc

rule cpp
    command = $cxx -MMD -MT $out -MF $out.d $cxxflags -c -Iinclude $in -o $out
    description = CXX $out
    depfile = $out.d
    deps = gcc

rule cc89
    command = $cc -MMD -MT $out -MF $out.d $cflags89 -c -Iinclude $in -o $out
    description = CC $out
    depfile = $out.d
    deps = gcc


rule cc_gen
    command = $cc -MMD -MT $out -MF $out.d $gen_cflags -c -Iinclude $in -o $out
    description = CC $out
    depfile = $out.d
    deps = gcc

rule ar
    command = ar rcu $out $in
    description = AR $out

rule link
    command = $cc $linkflags $in -o $out $libs -Iinclude
    description = LINK $out

rule cpplink
    command = $cxx $linkflags $in -o $out $libs -Iinclude
    description = LINK $out
]]

-- Rules for MSVC
local msvc_rules = [[
rule cc
    command = $cc /showIncludes $cflags /c /Iinclude $in /Fo:$out
    description = CC $out
    deps = msvc

rule cc89
    command = $cc /showIncludes $cflags /c /Iinclude $in /Fo:$out
    description = CC $out
    deps = msvc

rule cpp
    command = $cc /showIncludes $cxxflags /c /Iinclude $in /Fo:$out
    description = CXX $out
    deps = msvc

rule cc_gen
    command = $cc /showIncludes $cflags /c /Iinclude $in /Fo:$out
    description = CC $out
    deps = msvc

rule ar
    command = lib /OUT:$out $in
    description = AR $out

rule link
    command = link $linkflags $in $libs /Out:$out
    description = LINK $out

rule cpplink
    command = link $linkflags $in $libs /Out:$out
    description = CPPLINK $out
]]


function make_gcc_stub_cfg()
    return {
        cflags = '',
        gen_cflags = '',
        so_lflags = '',
        gen_lflags = '',
        gen_libs = '',
        compilers = 'cc = gcc\ncxx = g++\n'
    }
end


function make_gcc_stub(cfg)
    return "cflags = -std=c99 -O3 -Werror -Wall -Wextra " .. cfg.cflags .. "\n" ..
    "cxxflags = -std=c++11 -O3 -Werror -Wall -Wextra -Wno-attributes -march=native " .. cfg.cflags .. "\n" ..
    "cflags89 = -std=c89 -O3 -Werror -Wall -Wextra " .. cfg.cflags .. "\n" ..
    "exe_libs = -lm\nexe_linkflags = " .. cfg.so_lflags .. "\n" ..
    cfg.compilers ..
    "gen_cflags = $cflags -fPIC " .. cfg.gen_cflags .. "\n" ..
    "so_linkflags = -shared " .. cfg.so_lflags .. "\n" ..
    "gen_linkflags = -shared -fPIC " .. cfg.gen_lflags .. "\n" ..
    "gen_libs = -shared -fPIC " .. cfg.gen_libs .. "\n"
end


if platform == 'generic' then
    local sc = make_gcc_stub_cfg()
    sc.cflags = "-DNO_CPU_EXTENSIONS -DNOTHREADS -DNO_CUSTOM_DLLENTRY";
    stub = make_gcc_stub(sc) .. gcc_rules
elseif platform == 'gcc' or platform == 'mingw' then
    local sc = make_gcc_stub_cfg()
    sc.cflags = "-march=native"
    sc.gen_cflags, sc.gen_lflags = "-ffreestanding", "-nostdlib"
    stub = make_gcc_stub(sc) .. gcc_rules
elseif platform == 'gcc32' then
    local sc = make_gcc_stub_cfg()
    sc.cflags = "-march=i686 -m32"
    sc.gen_cflags, sc.gen_lflags = "-ffreestanding", "-m32 -nostdlib"
    sc.gen_libs, sc.so_lflags = "-lgcc -static-libgcc", "-m32"
    stub = make_gcc_stub(sc) .. gcc_rules
elseif platform == 'mingw-hx' then
    local sc = make_gcc_stub_cfg()
    sc.cflags = "-march=i686 -m32 -DUSE_WINTHREADS"
    sc.gen_cflags, sc.gen_lflags = "-ffreestanding", "-m32 -nostdlib"
    sc.gen_libs, sc.so_lflags = "-lgcc -static-libgcc", "-m32"
    stub = make_gcc_stub(sc) .. gcc_rules
elseif platform == 'zigcc' then
    local sc = make_gcc_stub_cfg()
    sc.cflags = "-march=native -DUSE_WINTHREADS"
    sc.get_cflags, sc.gen_lflags = "-ffreestanding", "-nostdlib"
    sc.compilers = "cc = zig cc\ncxx = zig c++\n"
    stub = make_gcc_stub(sc) .. gcc_rules
elseif platform == 'msvc' then
    exe_ext = '.exe'
    -- /WX if treat warnings as errors
    stub = "cflags = /O2 /W3 /arch:AVX2 /D_CRT_SECURE_NO_WARNINGS /GS-\n" ..
    "cxxflags = /O2 /W3 /arch:AVX2 /D_CRT_SECURE_NO_WARNINGS\n" ..
    "gen_cflags = $cflags\n" ..
    "cc = cl\n"..
    "exe_libs = advapi32.lib\n" ..
    "exe_linkflags = /SUBSYSTEM:CONSOLE\n" ..
    "so_linkflags = /DLL\n" ..
    "gen_linkflags = /DLL /NODEFAULTLIB\n"

    stub = stub .. "\nmsvc_deps_prefix = Note: including file:\n"
    -- BEWARE OF LOCALES AND NON-ENGLISH OUTPUT FROM SOME INSTALLATIONS
    -- OF THE MSVC COMPILER!
--    stub = stub .. "\nmsvc_deps_prefix = Примечание: включение файла:\n"

    -- sourceDependencies requires at least VS 16.7 (2022)
    -- /sourceDependencies $out.json
    -- deps=msvc_source_dependencies in some unapproved ninja commits

--    stub = stub .. "\nmsvc_deps_prefix = Note: including file:\n"
    stub = stub .. msvc_rules
else
    error("Unknown platform '" .. platform .. "'")
    return 1
end

------------------------------------------------
----- build.ninja file contents generation -----
------------------------------------------------

print("Generating build.ninja for the '" .. platform .. "' platform...")

stub = stub_crossplatform .. "\n" .. stub .. "\n"

local default_builds = {}

function add_sources(sources)
    local objfiles = {}
    for _, f in pairs(sources) do
        local objfile = f:gsub("%.c", ".o")    
        if f == 'specfuncs' then
            io.write(string.format("build $objdir/%s: cc89 $srcdir/%s\n", objfile, f))
        else
            io.write(string.format("build $objdir/%s: cc $srcdir/%s\n", objfile, f))
        end
        table.insert(objfiles, "$objdir/" .. objfile)
    end
    return objfiles
end

function add_objfiles(objfiles)
    for _, f in pairs(objfiles) do
        io.write("    " .. f .. " $\n")
    end
    io.write("\n");
end

function add_exefile(exefile, extra_objfiles, rule)
    local srcext, linkrule = ".c", "link"
    if rule == "cpp" or rule == "cxx" then
        srcext = ".cpp"
        linkrule = "cpplink"
    end
    io.write("build $objdir/" .. exefile .. ".o: " .. rule .. " $appsrcdir/" .. exefile .. srcext .. "\n")
    local exefile_full = "$bindir/" .. exefile .. exe_ext
    io.write("build " .. exefile_full .. ": " .. linkrule .. " $objdir/" .. exefile .. ".o ")
    if #extra_objfiles > 0 then
        add_objfiles(extra_objfiles)
    else
        io.write("\n");
    end
    io.write("  libs = $exe_libs\n")
    io.write("  linkflags = $exe_linkflags\n")
    table.insert(default_builds, exefile_full)
end

local file = io.open("build.ninja", "w")
io.output(file)
io.write(stub)

-- Build core library
local lib_objfiles = add_sources(lib_sources)
io.write("build " .. lib_name .. ": ar ")
add_objfiles(lib_objfiles)

-- Build batteries library
local bat_objfiles = add_sources(bat_sources)
io.write("build " .. batlib_name ..": ar ")
add_objfiles(bat_objfiles)

-- Build batteries

-- Build the command line tool executable
--table.insert(bat_objfiles, lib_name)
add_exefile("smokerand", {batlib_name, lib_name}, "cc")
add_exefile("test_crand", {batlib_name, lib_name}, "cc")
add_exefile("test_funcs", {lib_name}, "cc")
add_exefile("test_rdseed", {lib_name}, "cc")
add_exefile("test_cpp11", {batlib_name, lib_name}, "cpp")
add_exefile("calibrate_dc6", {lib_name}, "cc")
add_exefile("calibrate_linearcomp", {lib_name}, "cc")
-- Build extra executables: PE32 hack
io.write("build $objdir/pe32loader.o: cc $srcdir/pe32loader.c\n")
io.write("build $objdir/peparse.o: cc $appsrcdir/peparse.c\n")
io.write("build $bindir/peparse" .. exe_ext .. ": link $objdir/pe32loader.o $objdir/peparse.o " .. batlib_name .. " " .. lib_name .. "\n")
io.write("  libs = $exe_libs\n")
io.write("  linkflags=$exe_linkflags\n")
table.insert(default_builds, "$bindir/peparse" .. exe_ext)
-- Build extra executables: C89 compatible version
io.write("build $objdir/sr_tiny.o: cc89 $appsrcdir/sr_tiny.c\n")
io.write("build $bindir/sr_tiny" .. exe_ext .. ": link $objdir/sr_tiny.o $objdir/specfuncs.o\n")
io.write("  libs = $exe_libs\n")
io.write("  linkflags=$exe_linkflags\n")
table.insert(default_builds, "$bindir/sr_tiny" .. exe_ext)

-- Build generators
for _, f in pairs(gen_sources) do
    local gen_fullname = "$gen_bindir/" .. f .. so_ext
    io.write("build $gen_bindir/obj/" .. f .. ".o: cc_gen $gen_srcdir/" .. f .. ".c\n")
    io.write("build " .. gen_fullname .. ": link $gen_bindir/obj/" .. f .. ".o\n")
    io.write("  linkflags=$gen_linkflags\n")
    io.write("  libs=$gen_libs\n")
    table.insert(default_builds, gen_fullname)
end

-- Default rules
io.write("default ")
for k, v in pairs(default_builds) do
    io.write(v .. " ")
    if k % 2 == 0 then
        io.write("$\n    ")
    end
end
io.write("\n\n")

-- Finish the work
io.close(file)
io.output(io.stdout)
print("Success")
